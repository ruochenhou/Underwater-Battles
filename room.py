#!/usr/bin/env python3
# -*- coding: utf-8 -*-

from math import pi, hypot
import pygame as pg
from random import uniform
from collections import defaultdict

import config as c
import mobs as m
from special_effects import add_effect
from bubble import Bubble
from gui_elements import TextBox
from colors import WHITE, RED, VIOLET


class Room:
    def __init__(self):
        """
        List of bullets is made separately from list of mobs, because
        when mob is dead and deleted, its bullets should continue existing.
        'new_mobs' is a temporary list of mobs, which is created
        to draw the mobs of room player is being transported to.
        When player is transported, self.mobs = self.new_mobs.copy().
        Text is a text surface of room, containing rules of the game.
        Screen rectangle is used to check if mob's rectangle collides
        with it. If yes, then a mob is drawn.
        Gravity radius is a radius of circle around player, in which bubbles
        gravitate to player.
        'Bottom effects' are drawn below player, mobs, bubbles and bullets,
        other effects are 'Top effects'.
        """
        self.bubbles = []
        self.mobs = []
        self.new_mobs = []
        self.bullets = []
        self.homing_bullets = []
        self.bottom_effects = []
        self.top_effects = []
        self.text = None
        self.setup_text('')
        self.screen_rect = pg.Rect(0, 0, c.SCR_W, c.SCR_H)
        self.gravity_radius = 150

    def reset(self, new_game=False):
        """
        Method is called when a new game is started
        or a new room is visited. Resets all room data.
        """
        self.bubbles = []
        self.bullets = []
        self.homing_bullets = []
        self.top_effects = []
        self.bottom_effects = []
        self.mobs = [] if new_game else self.new_mobs.copy()
        self.new_mobs = []

    @staticmethod
    def encode_mobs(mobs):
        """
        :param mobs: list of objects (mobs)
        :return: dictionary [mob_name] -> number of mobs
        """
        mobs_dict = defaultdict(int)
        for mob in mobs:
            mobs_dict[mob.name] += 1
        return mobs_dict

    @staticmethod
    def decode_mobs(mobs_dict):
        """
        :param mobs_dict: dictionary [mob_name] -> number of mobs
        :return: list of objects (mobs)
        """
        mobs = []
        for mob_name in mobs_dict.keys():
            for i in range(mobs_dict[mob_name]):
                mobs.append(m.mob_factory(mob_name))
        return mobs

    def setup_new_mobs(self, new_mobs):
        """
        :param new_mobs: dictionary of new mobs, generated by Level Generator
        """
        self.new_mobs = self.decode_mobs(new_mobs)

    def setup_text(self, text):
        """
        :param text: list of strings
        sets background room text, explaining the rules of the game
        """
        self.text = TextBox(text, c.FONT_1, 47, True, WHITE, (400, 110))

    def delete_needless_bullets(self):
        """
        Method removes those bullets from list, that hit a target or are outside the room,
        and reduces the length of list to 100, if it is > 100.
        So the size of list becomes limited to avoid
        the situation of infinite filling the list.
        """
        tmp_bullets = []
        index = 0
        for bullet in self.bullets:
            if bullet.is_outside() or bullet.hit_the_target:
                tmp_bullets.append(index)
            index += 1

        tmp_bullets.reverse()
        for index in tmp_bullets:
            self.bullets.pop(index)

        while len(self.bullets) > 100:
            self.bullets.pop(0)

    def delete_dead_homing_bullets(self, sound_player):
        """
        Method deletes homing bullets with not positive health
        from list of homing bullets and plays a mob_death
        sound, if there are dead homing bullets.
        """
        sound_player.reset()
        dead_bullets = []
        index = 0
        for bullet in self.homing_bullets:
            if bullet.health <= 0:
                dead_bullets.append(index)
                sound_player.play_sound('mob_death')
            index += 1

        dead_bullets.reverse()
        for index in dead_bullets:
            self.homing_bullets.pop(index)

    def delete_needless_bubbles(self):
        """
        removes those bubbles from list, which are outside
        the room, so that player can't eat them
        """
        tmp_bubbles = []
        for index in range(len(self.bubbles)):
            if self.bubbles[index].is_outside():
                tmp_bubbles.append(index)
                tmp_bubbles.reverse()
        for index in tmp_bubbles:
            self.bubbles.pop(index)

    @staticmethod
    def delete_needless_effects(effects):
        """
        removes those effects from the given
        list, which have stopped running
        """
        tmp_effects = []
        for index in range(len(effects)):
            if not effects[index].running:
                tmp_effects.append(index)
        tmp_effects.reverse()
        for index in tmp_effects:
            effects.pop(index)

    def delete_dead_mobs(self):
        """
        Method deletes mobs with not positive health from
        list of mobs and replaces them with bubbles.
        """
        dead_mobs = []
        index = 0
        for mob in self.mobs:
            if mob.health <= 0:
                dead_mobs.append(index)
                self.add_bubbles(mob.x, mob.y, mob.bubbles)
            index += 1

        dead_mobs.reverse()
        for index in dead_mobs:
            self.mobs.pop(index)

    def update_bullets(self, dt):
        for bullet in self.bullets:
            bullet.update(dt)

        self.delete_needless_bullets()

    def update_homing_bullets(self, player_x, player_y, dt, sound_player):
        for bullet in self.homing_bullets:
            bullet.update(dt, player_x, player_y)

        self.delete_dead_homing_bullets(sound_player)

    def update_bubbles(self, x, y, dt):
        for bubble in self.bubbles:
            bubble.update(x, y, dt)

        self.delete_needless_bubbles()

    def update_effects(self, dt):
        for effect in self.top_effects:
            effect.update(dt)
        for effect in self.bottom_effects:
            effect.update(dt)

        self.delete_needless_effects(self.top_effects)
        self.delete_needless_effects(self.bottom_effects)

    def handle_bullet_explosion(self, x, y):
        """
        Changes mobs' states according to their positions relative
        to the explosion, and adds appropriate effects.
        :param x: x-coord of bullet
        :param y: y-coord of bullet

        """
        for mob in self.mobs:
            if hypot(x - mob.x, y - mob.y) <= 200:
                mob.health -= 20
                mob.change_body()
                add_effect('BigHitLines', self.top_effects, mob.x, mob.y)
        add_effect('PowerfulExplosion', self.bottom_effects, x, y)
        add_effect('Flash', self.top_effects)

    def move_objects(self, offset):
        """
        Method is called when the player is being transported
        to the next room. The objects of previous room become
        moved by the given offset to be drawn properly during
        player's transportation
        """
        for bubble in self.bubbles:
            bubble.move(*offset)

        for mob in self.mobs:
            mob.move(*offset)

        for bullet in self.bullets:
            bullet.move(*offset)

        for bullet in self.homing_bullets:
            bullet.move(*offset)

    def setup_gravity(self, gravity_radius):
        """
        Sets the new radius of player's gravitational field
        :param gravity_radius: radius of circle, in which
               the player's gravity exists
        """
        if self.mobs:
            self.gravity_radius = gravity_radius

            for bubble in self.bubbles:
                bubble.gravity_r = gravity_radius

    def maximize_gravity(self):
        """
        Method is called when all mobs in the room are dead.
        The radius of player's gravitational field is set equal to
        the diameter of room, so that every bubble starts
        gravitating to player regardless of his position in the room.
        Also speeds of bubbles are maximized to reach player faster.
        """

        for bubble in self.bubbles:
            bubble.gravity_r = 2 * c.ROOM_RADIUS
            bubble.maximize_vel()

    def update_mobs(self, player_x, player_y, dt):
        generated_mobs = []
        target = [player_x, player_y]
        for mob in self.mobs:
            mob.update(target, self.bullets, self.homing_bullets,
                       generated_mobs, self.screen_rect, dt)

        self.mobs.extend(generated_mobs)
        self.delete_dead_mobs()

    def update_new_mobs(self, player_x, player_y, dt):
        """
        Method updates positions and bodies of mobs of the room,
        player is being transported to.
        """
        target = (player_x, player_y)
        for mob in self.new_mobs:
            mob.update_pos(dt)
            mob.gamma = mob.count_gamma()
            if mob.body_rect.colliderect(self.screen_rect):
                mob.update_body(dt, target)

    def set_screen_rect(self, pos):
        self.screen_rect.center = pos

    def update(self, player_pos, dt):
        self.set_screen_rect(player_pos)

        self.update_mobs(*player_pos, dt)
        self.update_bubbles(*player_pos, dt)
        self.update_bullets(dt)
        self.update_effects(dt)

        if not self.mobs:
            self.maximize_gravity()

    def add_bubbles(self, mob_x, mob_y, bubbles):
        """
        :param mob_x: x coord of dead mob
        :param mob_y: y coord of dead mobs
        :param bubbles: list of the number of bubbles of 3 types: small, medium, big
        """
        for type_marker in range(len(bubbles)):
            for i in range(bubbles[type_marker]):
                angle = uniform(0, 2 * pi)
                self.bubbles.append(Bubble(mob_x, mob_y, angle, self.gravity_radius, type_marker))

    def draw_text(self, surface, dx, dy):
        self.text.draw(surface, dx, dy)

    def draw_bubbles(self, surface, dx, dy):
        for bubble in self.bubbles:
            bubble.draw(surface, dx, dy)

    def draw_mobs(self, surface, dx, dy):
        for mob in self.mobs:
            if mob.body_rect.colliderect(self.screen_rect):
                mob.body.draw(surface, dx, dy)

    def draw_new_mobs(self, surface, dx, dy):
        for mob in self.new_mobs:
            if mob.body_rect.colliderect(self.screen_rect):
                mob.body.draw(surface, dx, dy)

    def draw_bullets(self, surface, dx, dy):
        for bullet in self.bullets:
            bullet.draw(surface, dx, dy)

        for bullet in self.homing_bullets:
            bullet.draw(surface, dx, dy)

    def draw_top_effects(self, surface, dx, dy):
        for effect in self.top_effects:
            effect.draw(surface, dx, dy)

    def draw_bottom_effects(self, surface, dx, dy):
        for effect in self.bottom_effects:
            effect.draw(surface, dx, dy)

    def draw_transportation(self, screen, offset_new):
        self.draw_text(screen, *offset_new)
        self.draw_mobs(screen, *offset_new)
        self.draw_new_mobs(screen, *offset_new)
        self.draw_bubbles(screen, *offset_new)
        self.draw_bullets(screen, *offset_new)
